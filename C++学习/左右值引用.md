## 左值和右值

int i = 10;  //对象：一块内存区域

左值：能用在赋值语句赋值号左侧的东西，它能够代表 一个地址

右值：不能作为左值的值就是右值，右值不能出现在赋值语句左侧。

结论：C++的一条表达式，要么就是右值，要么是左值，不可能两者都不是。

左值能被当做右值使用。



用到左值的运算符有：

// 赋值运算符  =  

// 取地址 &

// string, vector  下标[]都需要左值，迭代器。

// i++,  5++； 可以判断运算符是否用到左值



左值表达式  就是左值， 右值表达式 就是右值

左值：代表一个地址，左值表达式的求值结果，就是一个对象。就得有地址。

右值：求值结果为对象的表达式，不代表一定是左值，具体分析。



## 引用分类

### 	左值引用（绑定到左值）

​		引用左值，绑定到左值上。左值引用不能绑定到右值，即int &ref = 1; //出错

### 	const 引用（常量引用）

​		也是左值引用，不希望改变值的对象。可以绑定到右值，即const int &ref=1; //ok。

### 	右值引用（绑定到右值）

​		引用右值，绑定到右值。必须绑定到右值的引用。

​		&&， 希望用右值引用来绑定一些即将销毁的或者是一些临时的对象上。

​		也是引用，理解成对象的名字。

​		能绑定到左值上的引用，一般都不能绑定到右值。右值引用也绑不到左值上。

​		临时变量被系统当做右值。//string &r3{"I love china"}; //出错，右值不能绑定到左值

​		int &&refrightvalue = 3; //绑定到一个常量

​		

​		++i; //左值表达式。++i直接给变量i+1, 然后返回i本身

​		i++;//右值表达式，i++,先产生一个临时变量_tempi，记录i（tempi=i;）的值用于使用的目的，再给i+1,

​			接着返回这个临时变量。临时变量这个东西，是右值。

#### 		右值引用的引入目的

​			C++11引入， &&， 代表一种新数据类型，引入的目的有

​			1）提高程序运行效率。把拷贝对象变成移动对象来提高程序运行效率。

​			2）移动对象如何发生。&&，（应付移动构造函数，应付移动赋值运算符用的）

## std::move 

​	C++11标准库的新函数

​	//std::move的能力，把一个左值强制转换成一个右值。带来的结果就是一个右值可以绑上去了。



## 临时对象探讨

### 临时对象概念

​	i++,  ++i

​	int i = 1;

​	int &&r1=i++; //r1和i之间没有关系

​	但用r1绑定后，临时对象系统就没有被释放了。



​	有一些临时对象，是代码书写问题而产生的。

​	临时对象会额外消耗系统资源，临时对象产生越少越好。

​	可以通过优化代码，把临时对象优化掉，尽量不让产生，以提高程序性能。

​	临时对象是在栈上，一般不用手动释放，临时对象产生和销毁有成本，减少临时对象可以提升性能。

### 产生临时对象的情况和解决

​	有三种情况和解决方案

#### 	（2.1）以传值的方式给函数传递参数

​			改造成引用传递的方式

```
    int Add(CTempValue tobj);
    int Add(CTempValue& tobj);
```

#### 	（2.2）类型转换生成的临时对象/隐士类型转换以保证函数调用成功

```
    CTempValue sum;
    sum = 1000; //系统干了三件事
```

​			1）编译器以1000为参数构造了一个临时对象

​			2）调用拷贝赋值运算符把这个临时对象的成员赋给sum对象

​			3)   销毁临时创建的CTmpValue对象

		优化， CTempValue sum = 1000;



​			隐士类型转换，以保证函数调用成功

​			char mystr[100] = "afdfdsf";

​			void calc(const string& str);

​			calc(mystr); //从char[] 转 string, 临时对象的产生和销毁就是成本，影响效率

​			

​			设计代码的时候，避免产生临时对象。

​			C++只会为const引用（const string& str）产生临时对象，而不会为非const引用（string& str）这种参数	产生临时对象。

#### 		（2.3）函数返回对象的时候

```
        CTempValue Double(CTempValue& tobj)
        {
            CTempValue tmp;
            tmp.val1 = tobj.val1*2;
            tmp.val2 = tobj.val2*2;
            return tmp;//调用了拷贝构造函数，系统产生了一个临时对象
        }
```

​					优化成

			CTempValue Double(CTempValue& tobj)
	        {
	            return CTempValue(tobj.val1*2, tobj.val2*2);
	        }

​		   代码优化

​			锻炼眼神和经验，才能看出哪里能产生临时对象。