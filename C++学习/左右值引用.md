## 左值和右值

int i = 10;  //对象：一块内存区域

左值：能用在赋值语句赋值号左侧的东西，它能够代表 一个地址

右值：不能作为左值的值就是右值，右值不能出现在赋值语句左侧。

结论：C++的一条表达式，要么就是右值，要么是左值，不可能两者都不是。

左值能被当做右值使用。



用到左值的运算符有：

// 赋值运算符  =  

// 取地址 &

// string, vector  下标[]都需要左值，迭代器。

// i++,  5++； 可以判断运算符是否用到左值



左值表达式  就是左值， 右值表达式 就是右值

左值：代表一个地址，左值表达式的求值结果，就是一个对象。就得有地址。

右值：求值结果为对象的表达式，不代表一定是左值，具体分析。



## 引用分类

### 	左值引用（绑定到左值）

​		引用左值，绑定到左值上。左值引用不能绑定到右值，即int &ref = 1; //出错

### 	const 引用（常量引用）

​		也是左值引用，不希望改变值的对象。可以绑定到右值，即const int &ref=1; //ok。

### 	右值引用（绑定到右值）

​		引用右值，绑定到右值。必须绑定到右值的引用。

​		&&， 希望用右值引用来绑定一些即将销毁的或者是一些临时的对象上。

​		也是引用，理解成对象的名字。

​		能绑定到左值上的引用，一般都不能绑定到右值。右值引用也绑不到左值上。

​		临时变量被系统当做右值。//string &r3{"I love china"}; //出错，右值不能绑定到左值

​		int &&refrightvalue = 3; //绑定到一个常量

​		

​		++i; //左值表达式。++i直接给变量i+1, 然后返回i本身

​		i++;//右值表达式，i++,先产生一个临时变量_tempi，记录i（tempi=i;）的值用于使用的目的，再给i+1,

​			接着返回这个临时变量。临时变量这个东西，是右值。

#### 		右值引用的引入目的

​			C++11引入， &&， 代表一种新数据类型，引入的目的有

​			1）提高程序运行效率。把拷贝对象变成移动对象来提高程序运行效率。

​			2）移动对象如何发生。&&，（应付移动构造函数，应付移动赋值运算符用的）

## std::move 

​	C++11标准库的新函数

​	//std::move的能力，把一个左值强制转换成一个右值。带来的结果就是一个右值可以绑上去了。



## 临时对象探讨

### 临时对象概念

​	i++,  ++i

​	int i = 1;

​	int &&r1=i++; //r1和i之间没有关系

​	但用r1绑定后，临时对象系统就没有被释放了。



​	有一些临时对象，是代码书写问题而产生的。

​	临时对象会额外消耗系统资源，临时对象产生越少越好。

​	可以通过优化代码，把临时对象优化掉，尽量不让产生，以提高程序性能。

​	临时对象是在栈上，一般不用手动释放，临时对象产生和销毁有成本，减少临时对象可以提升性能。

### 产生临时对象的情况和解决

​	有三种情况和解决方案

#### 	（2.1）以传值的方式给函数传递参数

​			改造成引用传递的方式

```
    int Add(CTempValue tobj);
    int Add(CTempValue& tobj);
```

#### 	（2.2）类型转换生成的临时对象/隐士类型转换以保证函数调用成功

```
    CTempValue sum;
    sum = 1000; //系统干了三件事
```

​			1）编译器以1000为参数构造了一个临时对象

​			2）调用拷贝赋值运算符把这个临时对象的成员赋给sum对象

​			3)   销毁临时创建的CTmpValue对象

		优化， CTempValue sum = 1000;



​			隐士类型转换，以保证函数调用成功

​			char mystr[100] = "afdfdsf";

​			void calc(const string& str);

​			calc(mystr); //从char[] 转 string, 临时对象的产生和销毁就是成本，影响效率

​			

​			设计代码的时候，避免产生临时对象。

​			C++只会为const引用（const string& str）产生临时对象，而不会为非const引用（string& str）这种参数	产生临时对象。

#### 		（2.3）函数返回对象的时候

```
        CTempValue Double(CTempValue& tobj)
        {
            CTempValue tmp;
            tmp.val1 = tobj.val1*2;
            tmp.val2 = tobj.val2*2;
            return tmp;//调用了拷贝构造函数，系统产生了一个临时对象
        }
```

​					优化成

			CTempValue Double(CTempValue& tobj)
	        {
	            return CTempValue(tobj.val1*2, tobj.val2*2);
	        }

​		   代码优化

​			锻炼眼神和经验，才能看出哪里能产生临时对象。



## 对象移动

### 对象移动的概念

C++11引入“对象移动”

### 移动构造函数

C++11 std::move,  主要解决程序运行效率问题

移动构造函数，C++11引入，目的是为了进一步提高程序效率。

（1）A移动B，A对象不能再使用了。

（2）移动，并不是把内存中的数据从一个地址  倒腾到另外一个地址。只是所有者变更。移动效率比拷贝高很多。

拷贝构造函数，A(const A& a){...}; //const左值引用

移动构造函数，A(const A&& a){...}; //右值引用



移动构造和移动赋值运算符完成的功能

（1）完成必要的内存移动，斩断原对象和内存的关系

（2）确保移动后源对象处于一种“即便被销毁也没有什么问题”的一种状态。A->B, 确保不再使用A，而是应该使用B。

​	static A getA()

​	{

​			A a;

​			return a; //临时对象，调用拷贝构造函数，如果类A有移动构造函数，

​				//那么会调用移动构造函数，把a对象的数据移动给了 临时对象

​	}

​	写移动构造函数，带指针的要谨慎小心的处理，处理不好系统就崩溃了

​	//移动构造函数

​	A(A &&tmpa):m_pb(tmpa.m_pb)//原来对象a指向的内存m_pb,直接让这个临时对象指向这段内存

​	{

​		**tmpa.m_pb=nullptr;** //如果不打断，a对象到生命周期，释放后新对象使用就会崩溃

​	}

​	![image-20220410114825223](\\192.168.1.114\samba\github\AVideoLearning\C++学习\截图\image-20220410114825223.png)

​	

​		A a = getA(); 

​		//调用了1次  构造函数，1次拷贝构造函数，2次析构函数

​		//增加移动构造函数后，调用1次构造函数，1次移动构造函数，2次析构函数



​		A a = getA();  //调用了1次  构造函数，1次拷贝构造函数，2次析构函数

​		A a1(a);  //1个拷贝构造函数, a是左值

​		

​		//移动构造函数

​	A(A &&tmpa) noexcept :m_pb(tmpa.m_pb)//原来对象a指向的内存m_pb,直接让这个临时对象指向这段内存

​	{

​		**tmpa.m_pb=nullptr;** //如果不打断，a对象到生命周期，释放后新对象使用就会崩溃

​	}

​		noexcept ,C++11新引入，声明和实现都加

​		用来通知标准库，不抛出异常。提高编译器工作效率。

​		

​		A a2(std::move(a);  //std::move，把左值变成右值，a2就调用移动构造函数。a就不能再用了。

​		A &&a3(std::move(a));  //没有建立新对象，不会调用移动构造函数，效果等同于对象a有了一个新别名a3

​			后面用a3操作。



​		A &&c = getA(); //相当于从getA()返回的临时对象被c接管了。

### 	

### 	移动赋值运算符

​		拷贝赋值运算符

​		A& operator=(const A& src)

​		{

​				if (this = =&src) return *this;

​				delete m_pb; //把自己这块内存干掉

​				m_pb=new B(*(src.m_pb)); //重新分配一块内存

​				return *this;

​		}		

​		移动赋值运算符

​		A& operator=(A && src) noexcept

​		{

​			if (this == &src)

​				return *this;

​			delete m_pb; //把自己这块内存干掉

​			m_pb= src.m_pb; //对方的内存直接拿过来（直接指过来）

​			src.m_pb=nullptr; //斩断源（对方和内存的关联斩断）

​			return *this;

​		}

​		A a  = getA();

​		A a2; //构造函数

​		a2 = std::move(a); //调用移动赋值运算符

​		

### 	合成的移动操作

​		某些条件下，编译器能合成移动构造函数，移动赋值运算符

​		a) 有自己的拷贝构造函数，拷贝赋值运算符，析构函数，编译器不会合成移动构造函数，移动赋值运算符。

​				所以，有一些类 没有移动构造函数和移动赋值运算符。

​		b) 如果没有移动构造函数和移动赋值运算符，系统会调用拷贝构造函数和拷贝赋值运算符代替。

​		c) 只有一个类没定义任何自己版本的拷贝构造函数和拷贝赋值运算符，且类的每个非静态成员都可以移动时，编译器才会为该类合成移动构造函数或者移动赋值运算符。

​		什么成员可以移动？

​		1）内置类型是可以移动的

​		2）类类型的成员，这个类有对应的移动操作相关的函数，就可以移动

​		此时编译器就能够合成移动构造函数和移动赋值运算符。



## 	总结

​			1）尽量给类增加移动构造函数和移动赋值运算符

​			2）noexcept

​			3）该给nullptr的就要给nullptr,让被移动对象处于一种能够被析构的状态。

​			4）没有移动构造或移动赋值函数，会调用拷贝构造或拷贝赋值代替

​		